Note 1: Excuse my anglais.
Note 2: Do as I say, not as I do.
Note 3:
TODO: make it an actual docx with hyperlinks and crossreferences to different elements (classes, functions, 
parameters etc). Also, do some general formatting.


As in its name, this app is designed to help volleyball enthusiasts and professionals, such as coaches, 
players, officials etc with sport-related activities, both during and off-match. 

This document is design to provide programming-savvy users with general architectural overview and specific 
references.

First, let me tell that the following is the fifth architectural design used in the development of this app. 
The first one was a complete mess, the second one was a structured mess, the third one was a relatively good 
construction based on said structured mess, the fourth one was some weird futuristic concept that was decided 
to try due to the pause in the development of the third one (hello, quarantine), and the current fifth one is 
another form of the third one but written from scratch due to said pause. 
As you can see, I'm happy to finally write this.

Now, a few words about what's what and how it works.

The app is creared using Python, Kivy, and PIL. 

There are several important cornstone-concepts of the code's architecture:

* OBJECTS, including
    * EVENTS
    * EVENT MANAGER
    * VISUAL ELEMENTS 
    * REQUESTS
    * LOGS

* GFX, including
    * SCREENS
    * POPUPS

* DATA CONFIG, including
    *APP CONFIG
    *MATCH CONFIG
    *LOCALIZATION
    *PROTOCOL IMAGE BORDERS
    *INTERVAL INSTRUCTIONS

* CORE FUNCTIONS 

So, basically, these are all the cornstones...

Before we start, let's go through the directory structure. In the root directory we have the following list:

    /docs 
    /gfx
    /logs
    /meta 
    /py
    DVA.exe 
    DVA.pyw 
    icon.ico

If you work in developer's version, i.e. you're me, you also have 

    run.pyw
    run.spec

We need to go deeper. This is description of (almost) each point, including sub-structure.

    run.pyw - this is a loading script for our main code. Long story short: customization files (app_ and match_config, localization, and 
    protocol image borders) were first creared with py extensions. The reason for that is that yours truly was not aware of the fact that 
    py.modules are imported during compilation and not runtime. As customization requires to apply changes whenever they done (saved, to be 
    precise), and changing the structure of importing those files would be very time consuming, the quick-fix was found in form of 
    "shell-script" that only has one job - run the main script with all of its dependencies imported during runtime.

    run.spec - "pre-cooked" spec file for faster compiling run.pyw 

    icon.ico - icon of the app.  
    
    DVA.pyw - main script which creates window, load logs etc. 

    DVA.exe - result of compiling run.spec. App's main and only executable.

    /docs - folder that contains this overview / references list, user instruction, and license information.

    /logs - folder that contains .txt file(s) for logs. Currently, we have two logs - for events and requests. Events' log is being creared and 
    fullfilled in different ways, including requests' log but only exists during runtime and has no .txt representation. Requests' log, on
    another hand, may or may not have .txt file, depending on if any request has occured.

    /meta - folder for meta stuff (as in the name). Currently contains localization and app config. 

    /gfx - folder that contains everything related to graphics, including visual files, design code, and some processing code, including 
    complicated processing code.
    The folder itself has the following structure:

        /background_pictures
        /match
        frontend.py 
        interval_instructions.py 
        visual_elements.py
        loading.gif

        Now, about every file, as usual:

        loading.gif - gif image that will be supposed to popup during time-consuming processes and 1)notify the user what's going on and that 
        the programm did not freeze, 2)block user from chaotically clicking and actually freezing the programm, 3)just generaly make the 
        programm looks nicer. As for now, the only one time-consuming process is generation of protocol image, and it does not work there due 
        to some technical difficulties. But it will in the future! 

        visual_elements.py - file that contains code of VisualElement class and all the classes that inheirit from it including their methods. 
        For explanaition of what Visual Element is, look below the directory structure.

        interval_instructions.py - file containing instructions for interval window in form of string. Basically, in the programm there's an 
        interval window that popups when there's some interval to wait, such as 1)before court entry, 2)before coin toss, 3)before set start, 
        4)before time out end, and has a timer, so interval_instructions.py stores instructions in str form to be executed by code in 
        frontend.py.

        frontend.py - backbone of all GUI in the programm. It has code for:
            
            Kivy application itself, 
            its screenmanager, 
            all the screens in said screenmanager, 
                including base screens for inheiritance, 
                and user-status versions, 
            list of widget references of said screens (see references for more info)
            all methods of said screens, such as __init__, loading (in terms of not physical loading of a screen, but rather logical loading, 
                i.e. what should be done in case of any backend / frontend changes that concern the screen irrelative to current 
                screen \ switching between screens, these functions may be called when not in a screen at all, or when already in a screen - 
                for example, the user is in the sanctions screen and selects a player who already has a warning. Warning button becomes 
                hidden.), as well as widget manipulation, 
            and popup manager, 
                including design and functions for popup windows,
            as well as background picture,
            team widget - specific class for connecting volleyball positions numbers with Python and Kivy indexing, and applying this 
                connecting in future code.
            two Kivy mixing behavior classes, 
            and, finally, two separate functions for scrolling processing.

        /match - folder that contains different images and sub-folders, such as sanction cards pictures, arrows picture for 
        cancelling / restoring events, and serve_ball.png, which is also our icon.

        /background_pictures - folder that contains...you name it...background pictures! To use your own background picture, add a file into 
        here with '.jpg' extension, call it 'background_' + *your_picture_name*, and then change app_background_picture variable in 
        meta/app_config.py to *your_picture_name*.
    
    /py - folder for backend code. It consists of:

        /match
        /requests
        core.py
        events.py 
        objects.py

        Now, as always:

        /match - folder containing files and folder(s) related specifically to match. Note: As mentioned before, the fourth architecture of the 
        app was weird. It consisted of different packages / modules, every one of which would hold code for different parts of the program, 
        such as match - referee, or non-match - player-profile etc, and the main program, which would -load, -unload, -rotate them and so for. 
        Now, /match folder is sort of following this idea. Base of any module are three files: core.py, events.py, objects.py. In /py we are 
        keeping general code, while in py/match we're saving code related directly to match flow. Why is it just /py/match and not 
        /py/match-referee? Well, first, it is so for now, and second, the difference between match flow for referees, head coaches, and staff is 
        not that big, there would be more cons than pros to disconnect it. However, in this module idea I've been using something like 
        'match-meta' which served as inheritance base for other 'match - modules'. Also, those of you who have read my plans for far future
        with this app, know that non-match modules will be at least 10 times more and bigger than match-modules.

        /py/requests - holds requests sending and processing files. See below for more info.

        core.py - holds core app functions.

	    events.py - holds app's events.

        objects.py - holds app's objects (Log and Request)

        /match has the following list:
			
        	/protocol 
			match_config.py
			core.py
			events.py
			objects.py
			
			/protocol - stores protocol-related files:
			
				image.png - protocol blank image
				borders.py - protocol borders zones (see Modding in user manual for more details)		

	
			match.config - stores match rules.
			
			core.py - match-related functions.

			events.py - match-related events.

			objects.py - match-related objects.

Now, finally, we can inspect those concepts in detail, so shall we? The following is the description of 
each category, what it is, what it does, why so etc. For an actual reference list, look below.
Let's start from up to down.

EVENTS 

Imagine this:

Matchtime. Head coach informs match officials that he's making a substitution. They do it using their 
tablet and user-profiles. Appropriate changes to backend (switch players in team.players) and frontend (update
 team line up numbers in match screen) are made (these are not all changes). Substitution object is created. 

Now, imagine this:

Matchtime. Head coach makes a substitution using their tablet. Appropriate changes to backend and frontend are 
made (these are not all changes). Substitution object is created. Information then is sent to officials tablets
using requests.

Now, imagine this:

Matchtime. The app has crashed midway for whatever reason but the substitution was already made before. The app
now copies information from the log, appropriate changes...

In two of these three cases, the algorithm is the following:

* User does something in GUI.
* Respective method of respective user object is called. 

    (Note: I'm using phrase 'user object' very freely here.
    There's no objects connected to user. The user is only represented by variable 'user-status' which is used
    to determine their status as in 'referee'/'head coach'/'viewer' etc and to load correct app mode. If we're
    talking about match mode, there's objects for humans, as well as Match, Set, Substitution, Sanction etc.
    They are created for the purposes of naturality and linking into a code.)

* This method deals with call-specific details (like, releasing mistake button in the match screen if the method
  is player.mistake())
* Also, this methond send signal to event manager that respective event needs to be created.
* Specific event class does not have its own __init__ function but inheirits from Event class itself which does.
* Event class does some processing with logs, requests, and so on, depending on different parameters, and calls
  create() function of said specific event class which does all the frontend, backend, and objects 
  manipulations.
* Then, if necessary, event manager does post-event processing.

If we're using logs instead, then we pass different parameters to event manager and event class itself while
creare() function remains the same.
This allows us to ensure the same effects and behavior when we're doing the same action in different ways.

So, basically, this is it. An Event is an object that represents the effects of the action (event) that has 
happened and allows us to centralize its processing, irregardless of source of origin, user-status etc.

Look py/events.py or py/match/events.py in directory structure or references for more information.

EVENT MANAGER

Some events are independent. Some are not. Sometimes we need to delete / restore event.
This is what event manager is for.

Dependent events are events that are not first in events chain, and that are creared not by user but app's 
logic. An example:

User issues a penalty to a player (SanctionIssued) -> If this is standard rules, point is assigned to another
team (Point_sReceived) -> If this is the last point of the set (set point), the set ends (yeah, I know about
referees' recommendation not to issue penalty on set point) (SetEnd) -> If this is the last set, the match 
ends (MatchEnd).

In this example, SanctionIssued is an independent event, while Point_sReceived, SetEnd, and MatchEnd are
dependent events. Some events are always in / dependent, some are mixed.

Handeling event chains from Event class itself is difficult cause they require different processing and is
just better when done via event manager.

Event manager also deals with events deletion / restoration. It does so by:

* calling event's __delete__ and restore (which is basically create function with different wrapping)
  functions.
* keeping and updating two lists: cancelled_events_ids, and created_events_ids which are then being used to
  determine which events to delete / restore (the last ones).
* maintaining event chains: if the event to delete / restore is dependent, it'll delete / restore all events up 
  to the independent one.

Look py/events.py or py/match/events.py in directory structure or references for more information.

VISUAL ELEMENTS

Imagine, if Team object would have a list named 'name_labels' which would contain all the Kivy Label widgets
which displays team's name. And, when, for example, team receives warning, we could change the color of these
Labels to yellow. And, maybe, some other functions, more complicated. And, maybe, we could dynamically change
some attributes of those widgets depending on our backend?

Visual Element is a cool interface between frontend and backend. It has the following structure:

* elements - list of widgets associated with this Visual Element.
* parameters - list of different values (text, opacity, color etc) to be set in elements when loaded if 
  applicable.
* load function - applying parameters to elements 
* elements management functions - add, delete, clear element(s). See below for more information.
* specific functions - like penalty() for TeamName or rotate() for TeamLineUp.

Note about elements management functions: 
    
    In the third version of the architecture Visual Elements were pretty much constant. team.Name = TeamName()
    was created once and then, when needed to be update due to, say, sides change after set end, elements
    would be updated and Visual Element would be re-loaded.
    However, during writing of the code, it was noticed that re-initialisation of Visual Elements has no 
    downsides and is somehow easier to work with. Thus, now changing elements list is done by creating new
    Visual Element.
    
    There also were is_active parameter, and unload() function, which are now deleted.

Look gfx/visual_elements.py in directory structure or references for more information.

REQUESTS 

App's requests are pretty much standard Python requests library with some interface build around it.

It can work with meta data, add itself into the log, and has two different ways of working with no connections:
either throw a popup, or add them into queue and send when Internet re-appears.

Requests folder has two files for each request: init and process. The former stores request preparation code
which is executed before sending, the latter stores reply body's processing code which is executed after.

Internet address to which requests are send is stored in app_config.

Look py/core.py or py/match/core.py in directory structure or references for more information.

LOGS 

Logs in the app are very simple. 

They consits of two sublogs. The first one, just a log, stores approximate return of the __dir__ function of
the object to store, while the deep log stores the actual object.

Logs obviously have functions to add (both to normal log and deeply) but have no delete element(s) function
in themselves. They do have functions though to return either specific or all elements with the given values 
of specific indexes. Also, optionally, they can be saved into .txt file or just be kept in memort during 
runtime.

Note: If there's an unfinished match, events from it will be loaded into Events log which will be created on
app load and all the events will be passed through event manager, thus restoring state of the app (and match)
which it had before execution stopped.

Look py/objects.py or /logs in directory structure or references for more information.


CORE FUNCTIONS

Basically, it's functions that do not belong to any package's object or event, and thus are brought 
together here. They're more 'general', and user usually does not interact with them but with the code that
interacts with them.
The word 'core' cause it sounds cool. 

Example: 

Calculating name strings. 

From server we're getting, among other things, list of people involved in a request with their names and last 
name. But there are different rules for processing paperwork in different countries. For example, in Northern 
America it's always LASTNAME, FIRSTNAME. Last name all capital, comma, whitespace, first name all capital. In 
my city league though (Eastern Europe) it's Last name, and then, if the last name is not unique in the document, 
comma, whitespace, and start adding by one letter to each person untill the name string does not become unique,
but don't finish on vowel. Put a period at the end except for if all letters of the first name have been used. 

We're using this function when we're processing request reply and save the results in Person objects for the 
correct displaying people's name according to paperwork rules in different people lists throughout the app 
(substitutions list, for example).

Look py/core.py or py/match/core.py in directory structure or references for more information.

INTERVAL INSTRUCTIONS

Basically, it's a list of strings with some command that will be passed to exec() function as an argument when
the time of the interval with that id passes. Look /gfx/interval_instructions.py in directory structure or
references for more information.

PROTOCOL BORDERS

After the end of a match, the app generates a protocol image which is to be used as any volleyball match
protocol. This file contains information about top-left and bottom right coordinates of the area in which 
text data relative to name needs to be inserted. Look Modding section of the user manual, or 
/py/match/protocol/borders.py in directory structure or references for more information.

LOCALIZATION 

Localization is stored in /meta/localization.py divided in list named after context of their usage. Those
lists themselves are divided into sub-list each of which contains strings in their respective language.
language_code from /meta/app_config specifies which sub-list will be used. General way of importing string is
*list group name*[language_code][needed_string_index]
Please, note that all formatting is done manually. Some strings are divided into two to put variable's value
inside them. Look Modding section of the user manual, or /meta/localization.py in directory structure or 
references for more information.

MATCH CONFIG

