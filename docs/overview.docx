#TODO: make it an actual docx with hyperlinks and crossreferences to different elements (classes, functions, parameters etc).

As in its name, this app is designed to help volleyball enthusiasts and professionals, such as coaches, players, officials etc with sport-related activities, both during and 
off-match. 

This document is design to provide programming-savvy users with general architectural overview and specific references.

First, let me tell that the following is the fifth architectural design used in the development of this app. The first one was a complete mess, the second one was a structured mess, 
the third one was a relatively good construction based on said structured mess, the fourth one was some weird futuristic concept that was decided to try due to the pause in the 
development of the third one (hello, quarantine), and the current fifth one is another form of the third one but written from scratch due to said pause.
As you can see, I'm happy to finally write this.

Now, a few words about what's what and how it works.

The app is creared using Python, Kivy, and PIL. 

There are several important cornstone-concepts of the code's architecture:

* OBJECTS, including
    * EVENTS
    * VISUAL ELEMENTS 
    * REQUESTS
    * LOGS

* SCREENS

* DATA CONFIG, including
    *APP CONFIG
    *MATCH CONFIG
    *LOCALIZATION
    *PROTOCOL IMAGE BORDERS
    *INTERVAL INSTRUCTIONS

* CORE FUNCTIONS 

So, basically, these are all the cornstones...

Before we start, let's go through the directory structure. In the root directory we have the following list:

    /docs 
    /gfx
    /logs
    /meta 
    /py
    DVA.exe 
    DVA.pyw 
    icon.ico

If you work in developer's version, i.e. you're me, you also have 

    run.pyw
    run.spec

We need to go deeper. This is description of (almost) each point, including sub-structure.

    run.pyw - this is a loading script for our main code. Long story short: customization files (app_ and match_config, localization, and protocol image borders) were first 
    creared with py extensions. The reason for that is that yours truly was not aware of the fact that py.modules are imported during compilation and not runtime. As customization
    requires to apply changes whenever they done (saved, to be precise), and changing the structure of importing those files would be very time consuming, the quick-fix was found
    in form of "shell-script" that only has one job - run the main script with all of its dependencies imported during runtime.

    run.spec - "pre-cooked" spec file for faster compiling run.pyw 

    icon.ico - icon of the app.  
    
    DVA.pyw - main script which creates window, load logs etc. 

    DVA.exe - result of compiling run.spec. App's main and only executable.

    /docs - folder that contains this overview / references list, user instruction, and license information.

    /logs - folder that contains .txt file(s) for logs. Currently, we have two logs - for events and requests. Events' log is being creared and fullfilled in different ways, 
    including requests' log but only exists during runtime and has no .txt representation. Requests' log, on another hand, may or may not have .txt file, depending on if any 
    request has occured.

    /meta - folder for meta stuff (as in the name). Currently contains localization and app config. 

    /gfx - folder that contains everything related to graphics, including visual files, design code, and some processing code, including complicated processing code.
    The folder itself has the following structure:

        /background_pictures
        /match
        frontend.py 
        interval_instructions.py 
        visual_elements.py
        loading.gif

        Now, about every file, as usual:

        loading.gif - gif image that will be supposed to popup during time-consuming processes and 1)notify the user what's going on and that the programm did not freeze, 2)block
        user from chaotically clicking and actually freezing the programm, 3)just generaly make the programm looks nicer. As for now, the only one time-consuming process is 
        generation of protocol image, and it does not work there due to some technical difficulties. But it will in the future! 

        visual_elements.py - file that contains code of VisualElement class and all the classes that inheirit from it including their methods. For explanaition of what Visual
        Element is, look below the directory structure.

        interval_instructions.py - file containing instructions for interval window in form of string. Basically, in the programm there's an interval window that popups when
        there's some interval to wait, such as 1)before court entry, 2)before coin toss, 3)before set start, 4)before time out end, and has a timer, so interval_instructions.py
        stores instructions in str form to be executed by code in frontend.py

        frontend.py - backbone of all GUI in the programm. It has code for:
            
            Kivy application itself, 
            its screenmanager, 
            all the screens in said screenmanager, 
                including base screens for inheiritance, 
                and user-status versions, 
            all methods of said screens, such as __init__, loading (in terms of not physical loading of a screen, but rather logical loading, i.e. what should be done in case of 
                any backend / frontend changes that concern the screen irrelative to current screen \ switching between screens, these functions may be called when not in a screen 
                at all, or when already in a screen - for example, the user is in the sanctions screen and selects a player who already has a warning. Warning button becomes 
                hidden.), as well as widget manipulation, 
            and popup manager, 
                including design and functions for popup windows,
            as well as background picture,
            team widget - specific class for connecting volleyball positions numbers with Python and Kivy indexing, and applying this connecting in future code.
            two Kivy mixing behavior classes, 
            and, finally, two separate functions for scrolling processing.

        /match - folder that contains different images and sub-folders, such as sanction cards pictures, arrows picture for cancelling / restoring events, and serve_ball.png,
        which is also our icon.

        /background_pictures - folder that contains...you name it...background pictures! To use your own background picture, add a file into here with '.jpg' extension, call it
        'background_' + *your_picture_name*, and then change app_background_picture variable in meta/app_config.py to *your_picture_name*.
    
    /py - folder for backend code. It consists of:

        /match
        /requests
        core.py
        events.py 
        objects.py

        Now, as always:

        /match - folder containing files and folder(s) related specifically to match. Note: As mentioned before, the fourth architecture of the app was weird. It consisted of different packages / modules, every one of which would hold code for different parts of the program, such as �match - referee�, or �non-match � player-profile� etc, and the main program, which would -load, -unload, -rotate them and so for. Now, /match folder is sort of following this idea. Base of any module are three files: core.py, events.py, objects.py. In /py we are keeping general code, while in py/match we�re saving code related directly to match flow. Why is it just /py/match and not /py/match-referee? Well, first, it is so for now, and second, the difference between match flow for referees, head coaches, and staff is not that big, there would be more cons than pros to disconnect it. However, in this module idea I�ve been using something like �match-base� which served as inheritance base for other �match-� modules�

        /py/requests - holds requests sending and processing files. See below for more info.

        core.py - holds core app functions.

	    events.py - holds app's events.

        objects.py - holds app's objects (Log and Request)

        /match has the following list:
			
        	/protocol 
			match_config.py
			core.py
			events.py
			objects.py
			
			/protocol - stores protocol-related files:
			
				image.png - protocol blank image
				borders.py - protocol borders zones (see Modding in user manual for more details)		

	
			match.config - stores match rules.
			
			core.py - match-related functions.

			events.py - match-related events.

			objects.py - match-related objects.


Now, finally, we can inspect those concepts in detail, so shall we? The following is the description of 
each category, what it is, what it does, why so etc. For an actual reference list, look below.
Let's start with the simpliest now. 

CORE FUNCTIONS

Basically, it's functions that do not belong to any package's object or event, and thus are brought 
together here. They're more 'general', and user usually does not interact with them but with the code that
interacts with them.
The word 'core' cause it sounds cool. 

Example: 

Calculating name strings. 

From server we're getting, among other things, list of people involved in a request with their names and last 
name. But there are different rules for processing paperwork in different countries. For example, in Northern 
America it's always LASTNAME, FIRSTNAME. Last name all capital, comma, whitespace, first name all capital. In 
my city league though (Eastern Europe) it's Last name, and then, if the last name is not unique in the document, 
comma, whitespace, and start adding by one letter to each person untill the name string does not become unique,
but don't finish on vowel. Put a period at the end except for if all letters of the first name have been used. 

We're using this function when we're processing request reply and save the results in Person objects for the 
correct displaying people's name according to paperwork rules in different people lists throughout the app 
(substitutions list, for example).

INTERVAL INSTRUCTIONS

Basically, it's a list of strings with some command that will be passed to exec() function as an argument when
the time of the interval with that id passes. Look /gfx/interval_instructions.py in directory structure or
references for more information.

PROTOCOL BORDERS

After the end of a match, the app generates a protocol image which is to be used as any volleyball match
protocol. This file contains information about top-left and bottom right coordinates of the area in which 
text data relative to name needs to be inserted. Look Modding section of the user manual, or 
/py/match/protocol/borders.py in directory structure or references for more information.

LOCALIZATION 

Localization is stored in /meta/localization.py divided in list named after context of their usage. Those
lists themselves are divided into sub-list each of which contains strings in their respective language.
language_code from /meta/app_config specifies which sub-list will be used. General way of importing string is
*list group name*[language_code][needed_string_index]
Please, note that all formatting is done manually. Some strings are divided into two to put variable's value
inside them. Look Modding section of the user manual, or /meta/localization.py in directory structure or 
references for more information.

MATCH CONFIG

